\subsection{Развитие баз данных}
\subsubsection{Простые и структурированные файлы}
Простые файлы состоят из:
\begin{itemize}
	\item заголовок - название столбцов
	\item данные - значения, разделённые запятой
\end{itemize}
В структурированных файлах в заголовках написано не только название столбца, но и его тип и длина.

\begin{remark}
	В структурированной версии можно быстро искать запись по номеру, то есть прочитать заголовок и узнать сколько занимает одна запись,умножить на нужный номер и прочесть сразу нужную запись.
\end{remark}

Достоинста:
\begin{itemize}
	\item простота чтения - написать код который будет читать такие данные просто
\end{itemize}

\begin{itemize}
	\item сложность поиска - не реализовать эффективный поиск которому не нужно было бы загружать всё в память
	\item сложность обработки
	\item сложно хранить нетривиальные типы данных например даты - теряется информация на какой позиции месяц, на какой день
	\item нет проверки целостности  (ограничений)
\end{itemize}

\subsubsection{Файловая система}
Устройство:
\begin{itemize}
	\item файл - одна запись
	\item иерархия записей - иерарзия каталогв
\end{itemize}

Достоинства:
\begin{itemize}
	\item простота реализации
	\item структурированные данные
\end{itemize}

Недостатки:
\begin{itemize}
	\item сложно извлекать требуемые данные
	\item нет проверки целостности
	\item большое кол-во файлов
\end{itemize}

\subsubsection{Иерархическая модель данных}
\begin{remark}
	Иерархия это хорошо, но использовать для этого файловую систему не эффективно.
\end{remark}

\paragraph{Деревья}
Отношение родитель - ребёнок соответствует каталогу и его подкаталогам в файловой системе, но не будет выделяться по файлу для каждой записи, вместо этого записи с одинаковым типом будут группироваться (благодаря этому не нужно будет лишний раз обходить файловую систему)

\enewline

Достоинства:
\begin{itemize}
	\item проверка целостности появляется благодаря стуктурированности (а именно связи родитель - ребёнок), например можно проверять что у человека нет двух оценок по одному предмету (хотя в файловой системе тоже можно было это делать)
	\item последовательное расположение записей - ускорение выполнения запросов
\end{itemize}

Недостатки:
\begin{itemize}
	\item представление только древовидных структур
	\item нет отношения многие ко многим, например у мн-ва студентов есть множество оценок по разным предметам и родителем будет студен, а детьми оценки или наоборот, запросы к обоим этим мн-вам выполниться эффективно не могут
\end{itemize}

\subsubsection{Сетевая модель данных}
Обобщение иерархических баз данных, нет единой строгой иерархии, есть базовая иерархия и есть дополнительные иерархии вида владелец - запись

\enewline

Достоинства:
\begin{itemize}
	\item представление всех типов связей (в том числе многие-ко-многим)
	\item возможность описания структуры
	\item эффективность реализации - эффективные запросы к обоим мн-вам из связи многие ко многим, но эффетивность разная из-за последовательной записи, только записи базовой иерархии записаны последовательно
\end{itemize}

Недостатки:
\begin{itemize}
	\item более сложная реализация
	\item жесткое ограничение структуры - если мы не подумали о каком то виде запросов заранее, то возможно для его исполнения придётся поднять все данные
\end{itemize}

\subsubsection{Реляционная модель данных}
\paragraph{Хранение}
Данные хранятся в таблицах, также в таблицах хранится информация о связях, связи задаются в запросах.

\enewline

Достоинства:
\begin{itemize}
	\item представление всех типов связей
	\item гибкая структура данных - можно задавать произвольные запросы
	\item математическая модель - позволяет говорить что некоторые запросы эквивалентны, то есть запрос не обязан исполняться как написан, мб исполнен любой эквивалентный запрос, выбирается самый эффективный из эквивалентных и получается тот же самый результат что и при исходном запросе потому что запрсы эквивалентны
\end{itemize}

Недостатки:
\begin{itemize}
	\item сложность реализации
	\item сложность представления иерархических данных
	\item сложность составления эффективных запросов
\end{itemize}

\subsubsection{Объектные базы данных}
Цель - хранить граф объектов, который уже находится в памяти, в базе данных. Обычная реализация - слой трансляции в реляционную базу данных

\enewline

Достоинства:
\begin{itemize}
	\item работа в терминах объектов а не записей
	\item логичное направление ссылок, например можем легко взять все оценки студента потому что есть соотв. отображение из студента в оценки
\end{itemize}

Недостатки:
\begin{itemize}
	\item сложность реализации
	\item сложность миграции схемы, например добавление поля объекту, в базе уже есть объекты без этого поля
	\item малая распространенность
\end{itemize}

\subsubsection{NoSQL}
Not only SQL. \\ \paragraph{Основная мысль} Реляционные базы данных умеют слишком много - они заточенны чтобы работать одинаково эффективно в куче различных сценариев, а если у нас какой то один сценарий, то можно оптимизировать ровно для него и написать эффективней.

\enewline

Различные типы:
\begin{itemize}
	\item документ-ориентированнеы - есть куча документов, важно что внутри них, главное уметь их быстро искать
	\item ключ-значение - всё что предоставляет движок - быстро по ключу достать значение
	\item табличные и столбчатые - хранить таблицы по стобцам, так если у нас множество запросов к конкретным двум столбцам, то мы сможем прочитать только их, читать придётся дважды (каждый столбец отдельно читается), но зато не нужно читать все столбцы как в табличном подходе
	\item графовые - хотим хранить графы
\end{itemize}

Достоинства:
\begin{itemize}
	\item большой выбор - отказываемся почти от всего кроме одного, у чего получаем большую производительность
	\item гибкость - в момент разработки базы, не тогда когда уже есть база
	\item скорость работы
\end{itemize}

Недостатки:
\begin{itemize}
	\item множество вещей делается в коде
	\item нет стандартных оптимизаторов
	\item легко ошибиться
\end{itemize}
