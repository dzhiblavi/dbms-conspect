\subsection{Оптимизация запросов. Выбор структуры исполнения запроса}

\begin{itemize}
	\item Из \textbf{унарных операций} первый приоритет имеет фильтрация, вторая -- проекция. В рамках перезаписи
	      запроса эти операции будут расставлены в соответствующем порядке;
	\item Оптимизация \textbf{множественных операций} не производится, в частности потому, что они редко применяются
	      последовательно;
	\item При \textbf{соединениях} порядок выполнения может существенно влиять на производительность, так
	      как он влияет на размеры промежуточных результатов. Число всевозможных планов выполнения соединений
	      (число деревьев с порядком на детях) есть $n! C_n \approx \frac{n! 4^n}{n^{\frac{3}{2}} \sqrt{\pi}}$. При малых $n$
	      допустим полный перебор всех вариантов.
\end{itemize}

Таким образом, при большом числе соединений (что является типичным) имеется крайне много возможных
планов исполнения. Существует ряд эвристических правил, существенно сужающих множество планов
исполнения, которые следует рассматривать планировщику.

\subsection{Планирование операций}

\textbf{Правило 1. Совершаются только запрошенные соединения}. Таблицы соединяются только если они
записаны рядом. Обоснование: вероятно в запросе следование подряд таблиц несет некоторый смысл, и
результаты соединений реже будут вырождаться в декартовы произведения.

\begin{example}
	\enewline
	\begin{lstlisting}[language=SQL]
    select * from Student natural join Points
    natural join Courses
    \end{lstlisting}

	Допустимые планы исполнения:
	\begin{align}
		 & (Students \bowtie Points) \bowtie Courses \\
		 & (Points \bowtie Courses) \bowtie Students
	\end{align}

	Недопустимый план исполнения:
	\begin{align}
		 & (Students \bowtie Courses) \bowtie Points
	\end{align}
\end{example}

\textbf{Правило 2. Правый аргумент каждого соединения -- таблица}. Запрещено использовать в
качестве правого аргумента результат другого соединения. Обоснование: соединения увеличивают
результат, поэтому выгоднее иметь как минимум в одном из аргументов таблицу. Также планы,
порождаемые этим планов, позволяют использовать для соединений индекс правого аргумента для
ускорения исполнения.

\begin{example}
	\enewline
	\begin{lstlisting}[language=SQL]
    select * from Student natural join Points
    natural join Courses natural join Lecturers
    \end{lstlisting}

	Допустимые планы исполнения:
	\begin{align}
		 & ((Students \bowtie Points) \bowtie Courses) \bowtie Lecturers \\
		 & ((Points \bowtie Courses) \bowtie Students) \bowtie Lecturers
	\end{align}

	Недопустимый план исполнения:
	\begin{align}
		 & (Students \bowtie Points) \bowtie (Courses \bowtie Lecturers)
	\end{align}
\end{example}

\begin{remark}
	Количество планов, удовлетворяющих правилам, сокращается до $\approx n!$.
\end{remark}

\subsubsection{Динамическое программирование}

Рассмотрим задачу динамического программирования на подмножествах. Каждый узел символизирует
множество соединенных отношений и примененные виды упорядочивания. Задача -- найти план с
минимальными трудозатратами.

\begin{itemize}
	\item \textbf{База}. Перебираются множества из двух таблиц и способы соединения: полный
	      просмотр, частичный просмотр по кластеризованному индексу, поиск по индексу;
	\item \textbf{Шаг}. Ко множеству добавляются все возможные отношения с перебором всех методов
	      реализации слияния. Лучшие варианты сохраняются.
\end{itemize}

\begin{remark}
	Сложность решения задачи динамического программирования в большинстве случаев составляет
	$\mathcal{O}(2^n)$.
\end{remark}

\subsubsection{Альтернативные подходы}

\begin{itemize}
	\item \textbf{Рандомизированные алгоритмы}. Не применяются широко, поскольку определенность
	      трудозатрат на исполнение важнее.
	      \begin{itemize}
		      \item \textit{Итеративное улучшение}. Начало со случайного отношения и выбор наилучшего
		            соединения из оставшихся для каждого шага.
		      \item \textit{Эмуляция отжига}.
		      \item \textit{Двухфазная оптимизация}. Итеративное улучшение и эмуляция отжига.
		      \item \textit{Генетические алгоритмы}.
		      \item \textit{Машинное обучение}.
	      \end{itemize}
	\item \textbf{Точные алгоритмы}. Все алгоритмы применяются только для случая вложенного
	      перебора, который не является оптимальным способом соединения.
	      \begin{itemize}
		      \item \textit{Алгоритм Ибраки-Камеда}. Сложность: $\mathcal{O}(n^2 \log(n))$;
		      \item \textit{Алгоритм KBZ}. Зависит от вида формулы трудозатрат и использует поиск по
		            хешу. Сложность: $\mathcal{O}(n^2)$.
		      \item \textit{Алгоритм AB}. Основан на базе KBZ, смягчает ограничения на вид формулы.
	      \end{itemize}
\end{itemize}
