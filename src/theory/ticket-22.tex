\subsection{Представления и их обновление}

\subsubsection{Определение представлений}

\begin{definition}
	\textit{Представление} -- именованный запрос.
\end{definition}

Представления применяются для:

\begin{itemize}
	\item \textbf{Макросы},
	\item \textbf{Сокрытие данных},
	\item \textbf{Независимость от данных}. При обнаружении аномалий и декомпозиции таблицы
	      использование представлений позволяет обратно соединять таблицы прозрачно для пользователя.
\end{itemize}

\paragraph{Синтаксис}
\enewline

\begin{lstlisting}[language=SQL]
    create view <name> as <query>;
    drop view <name>;
\end{lstlisting}

\begin{remark}
	Представление -- не зафиксированные данные на момент создания. При каждом его использовании
	производится запрос.
\end{remark}

\begin{examples}
	\enewline
	\begin{lstlisting}[language=SQL]
    create view AveragePoints as
    select SId, avg(Points) from Points;

    create view StudentCourse as
    select s.FirstName, s.LastName, c.Name, p.Points
    from Students s natural join Points p natural join
    Courses c
    \end{lstlisting}
\end{examples}

\subsubsection{Обновление представлений}

Поддержка модифицирующих операций над представлениями является полезным инструментом и может
применяться для обеспечения независимости от данных и их сокрытия. Иными словами, ожидается, что
обновления в представлениях должны прозрачно производиться в таблицах, из которых оно составлено.
Важно заметить, что дополнительно требуется взаимная обратимость вставки и удаления.

\begin{remark}
	Обновление будет рассмотрено как последовательные удаление и вставка без промежуточной проверки
	целостности.
\end{remark}

Рассмотрим, как должно распространяться обновление через сеть операций, составляющих представление:

\begin{itemize}
	\item $\sigma_P (R)$. Вставим только кортеж, удовлетворяющий условию фильтрации, иначе
	      он не появится в представлении. Аналогично при удалении.
	\item $\pi_A(R)$. Вставим кортеж с дополненными значениями атрибутов по умолчанию. При
	      удалении данных из проекции необходимо удалить \textit{все} соответствующие кортежи.
	\item $\rho_{a=b}(R)$. Столбцы не добавляются и не удаляются. При вставке и удалении атрибуты
	      переименовываются в соответствии с операцией.
	\item $R_1 \cup R_2$. Назовем условия, при котором кортеж попадает в $R_1$ или
	      $R_2$
	      \textit{предикатами} соответствующих отношений. При вставке в представление будем проверять,
	      удовлетворяет ли кортеж предикату $R_1$, и в положительном случае будем добавлять
	      его в $R_1$. Аналогично, если кортеж удовлетворяет предикату $R_2$,
	      добавим его и туда. Таким образом если кортеж удовлетворяет предикатам $R_1$ и
	      $R_2$ одновременно, то кортеж следует добавить в оба отношения. При удалении
	      кортеж следует удалить как из $R_1$, так и из $R_2$.
	\item $R_1 \cap R_2$. Вставим кортеж одновременно в $R_1$ и
	      $R_2$. При удалении -- удалим его
	      одновременно из $R_1$ и $R_2$.
	\item $R_1 \setminus R_2$. Вставим или удалим кортеж из $R_1$. Заметим, что при
	      удалении также
	      корректно добавить кортеж в $R_2$, но это противоречит смыслу удаления.
	\item $R_1 \bowtie R_2$. При вставке и удалении в $R_1$ и $R_2$
	      соответственно вставляются
	      части кортежа, спроецированные на соответствующие отношения. При этом важно учитывать ограничения
	      целостности между отношениями $R_1$ и $R_2$:
	      \begin{itemize}
		      \item \textit{Один-к-одному}. Вставка и удаление производятся для каждого отношения.
		      \item \textit{Один-ко-многим}. Обязательна вставка в отношение со стороны ``многие'',
		            но со стороны ``один'' -- только если кортежа еще не было. Аналогично при удалении.
		      \item \textit{Многие-ко-многим}. С точки зрения БД такое отношение преобразуется в join
		            table с двумя отношениями \textit{один-ко-многим}.
	      \end{itemize}
\end{itemize}

\paragraph{Обновление в SQL}

Стандарт утверждает, что унарные операции ($\sigma_P (R)$, $\pi_A(R)$,
$\rho_{a=b}(R)$) являются обновляемыми, множественные ($R_1 \cup R_2$,
$R_1 \cap R_2$, $R_1 \setminus R_2$) -- не обновляемые. Соединения ``один-к-одному'' --
обновляемые, ``один-ко-многим'' -- обновляемые только со стороны ``многие''. ``Многие-ко-многим'',
формально, не существует, но при поддержке считается, что они не обновляемые.

\begin{remark}
	Большинство СУБД не поддерживают обновление представлений.
\end{remark}

\subsubsection{Материализованные представления}

\begin{definition}
	\textit{Материализованное представление} -- ``слепок'' данных на определенный момент времени.
\end{definition}

Материализованные представления обычно хранятся физически и не изменяются при изменении базовой
версии данных. Преимуществами являются быстрота выборки (сложные запросы не будут пересчитываться)
и возможность зафиксировать состояние БД на конкретный момент времени. Недостатки: необходимость
обновления при устаревании данных и необходимость занимать место в памяти.

\paragraph{Синтаксис}
\enewline

\begin{lstlisting}[language=SQL]
    create materialized view <name>
    [
        refresh [{fast | complete}] [on {demand | commit}]
        [start with <time>] [next <time>]
    ]
    as <query>;
    refresh materialized view <name>;
\end{lstlisting}

При выборе типа обновления \texttt{fast} изменения применяются инкрементально, то есть на
основе конкретных изменений данных, в то время как \texttt{complete} форсирует полный пересчет
данных. Опции \texttt{on demand} или \texttt{on commit} определяют, что пересчет необходимо
производить по требованию или при применении изменений соответственно.

\begin{example}
	\enewline
	\begin{lstlisting}[language=SQL]
    create materialized view AceragePoints
    refresh next dateadd(day, now(), 1)
    as select SId, avg(Points) from Points group by SId
    \end{lstlisting}
\end{example}

\begin{remark}
	Синтаксис объявления материализованных представлений во многом специфичен для конкретных СУБД.
	Также некоторые СУБД не поддерживают этот функционал в принципе.
\end{remark}
